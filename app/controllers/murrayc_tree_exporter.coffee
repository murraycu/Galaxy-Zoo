Spine = require 'spine'
SloanTree = require 'lib/sloan_tree'
JQuery = require 'jqueryify'
Underscore = require 'underscore/underscore'


class MurraycTreeExporter
  constructor: ->
    @xmlDoc = null
    @root = null

    @questions = {}

  _addNode: (parentNode, childNodeName) ->
    # Note: For some reason we can call createElement on the result of parseXML(), but not on the result of JQuery(parseXml()).
    elementCreated = @xmlDoc.createElement(childNodeName)
    return parentNode.appendChild(elementCreated) # Note that this returns a different type than createElement() - one that you can call append() on.

  _addTextNode: (parentNode, childText) ->
    # Note: For some reason we can call createElement on the result of parseXML(), but not on the result of JQuery(parseXml()).
    elementCreated = @xmlDoc.createTextNode(childText)
    return  parentNode.appendChild(elementCreated) # Note that this returns a different type than createElement() - one that you can call append() on.

  _addNodeWithText: (parentNode, childNodeName, childText) ->
    element = @_addNode(parentNode, childNodeName)
    return @_addTextNode(element, childText)

  _addQuestionNode: (question) ->
    elementQuestion = @_addNode(@root, "question")
    elementQuestion.setAttribute("id", question.id);

    # We use child nodes, instead of attributes, for these because they could contain newlines.
    @_addNodeWithText(elementQuestion, "title", question.title)
    @_addNodeWithText(elementQuestion, "text", question.text)
    @_addNodeWithText(elementQuestion, "help", question.helpText)

    for key, answer of question.answers
      elementAnswer = @_addNode(elementQuestion, "answer")
      elementAnswer.setAttribute("id", key)
      elementAnswer.setAttribute("icon", answer.icon);

      # We use a child node, instead of an attribute, for this because it could contain newlines.
      @_addNodeWithText(elementAnswer, "text", answer.text)

      # The Galaxy-Zoo decision trees, such as sloan_tree.coffee,
      # Use the actual question text as the leadsTo value,
      # but that is silly, so we use the question ID:
      questionNext = question.nextQuestionFrom(key)
      if (questionNext != null)
        elementAnswer.setAttribute("leadsTo", questionNext.id);

      # TODO: Deal with checkboxes. These are just a sign that the
      # question can have multiple answers.
      # The leadTo is therefore for the whole question.
      # Maybe just mark the question as allowing multiple-selection of answers
      # and specify a leadTo for the whole question, to be used when there is
      # no leadTo for the answer.
         

   _getQuestionsForQuestionAnswers: (question) ->
      for key, answer of question.answers
        questionNext = question.nextQuestionFrom(key)
        if (questionNext != null)
          @questions[questionNext.id] = questionNext
          @_getQuestionsForQuestionAnswers(questionNext)

   _getQuestions: ->
     question = SloanTree.first()
     if (question == null)
       return;

     @questions[question.id] = question
     @_getQuestionsForQuestionAnswers(question);

      
  # Use this to pretty-print the XML:
  # xmllint --format something.xml > something_pretty.xml
  getXmlForTree: ->
    # Create an XML document and add to it:
    xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
      <!-- This XML format is not at all official. I invented it. murrayc. 2014-07-29. -->
      <!-- This was generated by murrayc_tree_exporter.coffee -->
      <murrayc_zoonverse_questions xmlns=\"http://murrayc.com/murrayc_zoonverse_questions\" format_version=\"1\" />"
    @xmlDoc = JQuery.parseXML(xml)

    xmlDocJQuery = JQuery(@xmlDoc) # TODO: Why is this necessary?
    @root = xmlDocJQuery.find("murrayc_zoonverse_questions").get(0)

    #Iterate over the questions, after getting a sorted list of their IDs:
    #TODO: Sort sloan-10 after sloan-9, instead of after sloan-1, because that looks nicer.
    @_getQuestions()
    keys = Object.keys(@questions).sort();
    for key in keys
      question = @questions[key]
      @_addQuestionNode(question)

    txt = new XMLSerializer().serializeToString(@xmlDoc)
    txt = Underscore.escape(txt)
    return txt;


module.exports = MurraycTreeExporter
